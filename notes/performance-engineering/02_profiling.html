<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Profiling - Performance Engineering Notes</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_profiling.html" class="active"><strong aria-hidden="true">2.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="03_modeling.html"><strong aria-hidden="true">3.</strong> Performance Modeling</a></li><li class="chapter-item expanded "><a href="04_efficiency.html"><strong aria-hidden="true">4.</strong> Writing Efficient Code</a></li><li class="chapter-item expanded "><a href="05_parallelism.html"><strong aria-hidden="true">5.</strong> Multi-Core Systems and Parallelism</a></li><li class="chapter-item expanded "><a href="06_device_performance.html"><strong aria-hidden="true">6.</strong> System and Device Performance</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Performance Engineering Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lecture-2-profiling-and-performance-tracing"><a class="header" href="#lecture-2-profiling-and-performance-tracing">Lecture 2: Profiling and Performance Tracing</a></h1>
<p>This lecture goes into more detail about identifying optimisation opportunities, specifically, we identify:</p>
<ol>
<li>the hot path (the code that takes the most time)</li>
<li>the bottleneck within the hot path</li>
</ol>
<p>Both of these are functions of <strong>system behaviour</strong>, described by events.</p>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p><strong>Events</strong> are any change of the system state. Usually, we restrict events to a certain granularity, for example:</p>
<ul>
<li><strong>Simple/atomic events</strong> (executed an instruction, loaded an address, clock tick, etc.)</li>
<li><strong>Complex events</strong> (cache line evicted from L1 to L2 cache, instruction aborted due to misspeculation, etc.)</li>
</ul>
<p>An event may have an optional payload (which is metadata describing the event in more detail) and an accuracy: the event <strong>accuracy</strong> is the degree to which its value represents reality.</p>
<p>Events originate from an <strong>event source</strong>, which generally has two components:</p>
<ul>
<li>
<p>the <em>generator</em>, which generates a new occurrance of an event. This is usually online (during runtime or part of the system). For example, the code in the kernel that sends network packets can be considered a generator of network events.</p>
</li>
<li>
<p>the <em>consumer</em>, which processes the events. It can be offline (the events are not used for any meaningful purpose) or online (the events are used in some way, such as calculating statistics of the events).</p>
</li>
</ul>
<p>These events can be used for <strong>tracing</strong> or <strong>profiling</strong>.</p>
<h2 id="tracing"><a class="header" href="#tracing">Tracing</a></h2>
<p>A <strong>trace</strong> is a complete log of every state the system has ever been in during a given period of time. Thus, a trace is comprised by a sequence of ordered events.</p>
<p>The accuracy of a trace is <em>inherited</em> from the events. Importantly, <strong>event collection may have a high overhead</strong> during tracing, which can lead to problems.</p>
<h3 id="example-call-stack-tracing"><a class="header" href="#example-call-stack-tracing"><em>Example: Call stack tracing</em></a></h3>
<p>Call stack tracing consists of sampling snapshots of the call stack of the application at regular intervals. Every time a function calls another function, a new frame is added to the stack. Therefore, we can trace how long our program spends in each function call.</p>
<p>A call stack consists of different function frames, each of which contain the required and relevant state to execute the function: variables, the return address and the saved frame pointer (if not optimised away during compilation). Each frame's saved EBP (frame pointer) points to the function it was called from. Hence, we can <em>walk</em> through the stack by following the frame pointers.</p>
<p>However, walking the stack can be <strong>expensive</strong> if the call stack is very deep (as the complexity is linear in terms of the number of function calls). In particular, for small functions, call stack processing can be more expensive than the function itself (because we need to save the EBP).</p>
<h3 id="perturbation-and-sampling"><a class="header" href="#perturbation-and-sampling">Perturbation and sampling</a></h3>
<p>This issue is known as <strong>perturbation</strong>: the degree to which the performance of a system changes when it is being analysed. Although the overhead is unimportant (because we are not going to trace the program during production), perturbation can <strong>negatively affect accuracy</strong> if it is non-deterministic (ie: you don't know how much overhead you are adding).</p>
<p>We can reduce perturbation by reducing <strong>fidelity</strong> (the degree of exactness). In our context, this means:</p>
<ul>
<li>Perfect fidelity means every event is recorded</li>
<li>Reduced fidelity means not every event is recorded </li>
</ul>
<p>In practice, reducing fidelity works via <strong>sampling</strong>, where we collect events in regular intervals.</p>
<p>An <strong>interval</strong> is the distance between two samples being taken. We can specify interval lengths via:</p>
<ul>
<li>
<p><strong>Time-based intervals</strong>: set a hardware recurrent timer and sample whenever it runs out. The notion of time is usually captured via CPU reference cycles (because time in a CPU is not accurate, as clock rates may vary across different cores). These intervals are easy to interpret, as we are measuring time and this is inversely proportional to performance.</p>
</li>
<li>
<p><strong>Event-based intervals</strong>: defined in terms of the occurrence of events (e.g.: sample every fifth function call). This gives us accurate results with low noise (using hardware counters), however it can be tricky to interpret (as we are usually interested in time). </p>
</li>
</ul>
<p>Interval resolution is limited to (usually) discrete clock cycles, however time is continuous. This introduces a quantisation error when attributing an event to a particular clock cycle. For example, if we have an expensive SIMD instruction just before a simple MOV instruction, a profiler may tell us that the <code>MOV</code> instruction is being slow when in reality its the previous instruction which is slow (this is quantisation error).</p>
<p>Returning to the example of call stack sampling, we simply skip some events. This means some functions may be skipped but there is a good chance that expensive functions will be sampled more often. This gives us good performance and reduced perturbation.</p>
<h3 id="indirect-tracing"><a class="header" href="#indirect-tracing">Indirect tracing</a></h3>
<p>An example of event-based interval sampling is <strong>indirect tracing</strong>. The idea is that events dominate each other, so we should only trace the dominant events.</p>
<p>We can think of it as intervals defined by the execution flow: if we have an <code>if</code> statement, then all the code in the branch that is taken will be deterministically executed. Therefore, we do not need to trace every instruction in the branch, we can just record the fact that the branch was taken in the first place. Hence, we say that <strong>control-flow instructions dominate non-control-flow instructions</strong>. We can count how many times a branch is executed (known as basic block counting).</p>
<p>Indirect tracing can be used to reduce overhead/perturbation (because we don't have to sample every instruction), however the fidelity/accuracy depends on the event and how much indirection there is.</p>
<h2 id="profiling"><a class="header" href="#profiling">Profiling</a></h2>
<p>Profiling (in the context of performance engineering) is a characterisation of a system in terms of the resources it spends in the certain states. Since an event is a transition of states, we can derive a profile from events.</p>
<p>Specifically, a profile is an aggregate over the events of a specific metric. This is can be a global aggregate (eg: total cache misses, total CPU cycles) or an event-based aggregate (eg: cycles per instruction, cache misses by line of code).</p>
<p>Profiling is useful for:</p>
<ul>
<li>post-mortem analysis for ease of interpretation</li>
<li>reducing perturbation by aggregating traces into profiles in real-time (assuming aggregation is faster than writing the traces to memory)</li>
</ul>
<p>As mentioned earlier, events originate from <strong>event sources</strong>. These should be detailed, accurate and have little perturbation. Events can originate from:</p>
<ul>
<li>Software:
<ul>
<li>Library: manual instrumentation, logging</li>
<li>Compiler: automatic instrumentation</li>
<li>OS: kernel counters</li>
</ul>
</li>
<li>Hardware:
<ul>
<li>Performance counters</li>
</ul>
</li>
<li>Emulator: a hybrid of both, with minimal perturbation (but not scalable)</li>
</ul>
<h3 id="instrumentation"><a class="header" href="#instrumentation">Instrumentation</a></h3>
<p>Consists of augmenting the program with event logging code. There is no need for hardware support and extremely flexible. However, there is high overhead and high perturbation.</p>
<p>There are three approaches to instrumentation:</p>
<ul>
<li>
<p><strong>Manual instrumentation</strong>: basically using logging using <code>printf</code> (or a logging library).</p>
<ul>
<li>Advantages: fine-grained control, no hardware involvment</li>
<li>Disadvantages: high runtime and implementation overhead</li>
</ul>
</li>
<li>
<p><strong>Automatic source-level instrumentation</strong>: source-to-source rewriting, usually compiler-supported.</p>
<ul>
<li>Advantages: <strong>todo, see interactive lecture</strong></li>
<li>Disadvantages: less control, compiler support required</li>
</ul>
</li>
<li>
<p><strong>Automatic binary instrumentation</strong>:</p>
<ul>
<li>Static (compile-time): simple, portable, instrumentation overhead is easily assessed from the binary</li>
<li>Dynamic (runtime): no recompilation, works on a running process and with JIT-compiled code</li>
</ul>
</li>
</ul>
<p>An example of automatic instrumentation is the LLVM XRay framework, which can be used to automatically log every function call and exit. One limitation of this framework is that it only retains function calls that take more than 5 microseconds. For higher fidelity and lower overhead, we can look at performance counters.</p>
<h2 id="performance-counters"><a class="header" href="#performance-counters">Performance counters</a></h2>
<p>An alternative to instrumentation for profiling is analysing <strong>performance counters</strong>.</p>
<p>Although software counters exist in OS kernels (packets sent/received, virtual memory operations, etc.), they are not often used. Instead, we prefer <strong>hardware performance counters</strong>.</p>
<p>Hardware performance counters are special registers that can be configured to count <em>low-level events</em>. Only a fixed number can be active during the profiling process and can be used to collect events and/or intervals.</p>
<p>Unfortunately, these are often buggy, poorly documented and may be inaccurate. However, the common performance counters are usually fine.</p>
<p>In Linux, we can use the <code>perf</code> tool to access different hardware performance counters. Many of these are often associated to cache behaviour, such as cache line evictions or cache misses.</p>
<h2 id="case-study-microarchitectural-bottleneck-analysis"><a class="header" href="#case-study-microarchitectural-bottleneck-analysis"><em>Case Study: Microarchitectural bottleneck analysis</em></a></h2>
<p>One of the most important types of analyses you can carry out to increase performance of software is by analysing behaviour and identifying bottlenecks at the microarchitectural level.</p>
<h3 id="1-cpu-pipelining-and-frontend-stalls"><a class="header" href="#1-cpu-pipelining-and-frontend-stalls">1. CPU pipelining and frontend stalls</a></h3>
<p>First, we should understand how <strong>CPU pipelining</strong> works. A CPU maintains a pipeline of instructions which are at different stages: fetch, decode, execute, memory and write-back. The ideal situation is that the pipeline is filled, so as many instructions are being processed at a time (instruction-level parallelism). At every cycle, an instruction is <em>retired</em> (removed) from the pipeline.</p>
<p>Unfortunately, having a full pipeline isn't always possible due to <strong>control hazards</strong>, ie: jump instructions, because we need to change the instruction pointer. We cannot know where to jump to until the JMP instruction reaches the last slot of the 5-stage pipeline, meaning we only retire 1 instruction from 5 cycles (80% less than the ideal case). This scenario is known as a <strong>frontend stall</strong>, because the front of the pipeline doesn't know what instruction to read yet.</p>
<p><strong>Branch prediction</strong> is a technique where the CPU speculates upon which branch may be taken and starts loading and executing instructions from within that branch immediately, rather than stalling the pipelining.</p>
<p>When the comparison/branch instructions are finally retired, the CPU figures out if we have correctly predicted the branch. If it mispredicts the branch, the CPU has to flush/clear the pipeline and restart from the branch instruction, which negatively affects performance. Such discarded instructions are referred to <em>abandoned instructions</em>.</p>
<h3 id="2-resource-stalls"><a class="header" href="#2-resource-stalls">2. Resource stalls</a></h3>
<p>An <strong>ALU stall</strong> refers to when an expensive arithmetic instruction takes several clock cycles in the execution/memory stage and blocks the stream of instructions through the pipeline. For example, division is often an ALU stall because it may take several cycles to execute.</p>
<h3 id="3-memory-subsystem-and-data-stalls"><a class="header" href="#3-memory-subsystem-and-data-stalls">3. Memory subsystem and data stalls</a></h3>
<p>Depending on what memory we access (L1 cache, L2 cache, LL cache or main memory), we will get different latencies.</p>
<p>The graph below shows that if we access values in nearby memory locations, the cost (in CPU cycles) is much lower. The greater the access stride, the more costly it is to read memory. This is due to how caches work and the size of cache lines (every 64 bytes corresponds to a different cache line).</p>
<img src="assets/02_memory_access_latency_locality.png">
<p>The next graphs shows memory access latency (in cycles) depending on the size of the data. For a 4kB array, all our memory access will be hitting the L1 cache. Between 32kB and ~4MB, we access the last-level (L3) cache.</p>
<img src="assets/02_memory_access_latency_size.png">
<p>The key takeaway here is that CPUs can also stall on memory accesses.</p>
<h3 id="bottleneck-analysis"><a class="header" href="#bottleneck-analysis">Bottleneck analysis</a></h3>
<p>Given the different types of stalls, we can identify different microarchitectural bottlenecks in order through which they may arise in the pipeline:</p>
<ol>
<li>Memory access stalls (which fetching the operands for an instruction)</li>
<li>Resource allocation stalls (ALU stalls)</li>
<li>Branch mispredictions (leading to abandonded instructions due to flushing)</li>
<li>Control-flow dependencies</li>
</ol>
<p>We can use the following decision tree to determine what the bottleneck is. Our starting node asks if a micro-operation has been issued (ie: has something happened?, has our pipeline advanced?).</p>
<img src="assets/02_microarch_bottleneck_analysis.png">
<p>If nothing has happened and there is no resource allocation stall (such as an ALU stall), then this is a frontend-bound issue, ie: no instructions entered the pipeline, likely due to a control-flow dependency (too many function calls or jumps in memory).</p>
<p>Otherwise, the bottleneck is backend-bound: cache miss stalls or resource stalls.</p>
<p>If there was a micro-op issued and some progress was made in the pipeline, then the instruction can either retire (good case) or abandoned due to bad speculation (likely due to too many branching code).</p>
<br>
<br>
<br>
<h2 id="tutorial-notes"><a class="header" href="#tutorial-notes">Tutorial notes</a></h2>
<p><strong>Possible exam questions</strong>: given an algorithm/data structure, what would the profile look like for it?</p>
<p>Ie: profile of a rebalancing operation in a Red-Black Tree (considering the size, depth, etc.)</p>
<ul>
<li>
<p>A lot of code/instructions (long algorithm, a lot of recursion) -&gt; likely to be frontend bound</p>
</li>
<li>
<p>Random memory accesses -&gt; memory-bound</p>
</li>
<li>
<p>Code is highly OOP with a nice API (many function calls) -&gt; frontend bound</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="01_intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="03_modeling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="01_intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="03_modeling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
