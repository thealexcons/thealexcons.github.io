<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>System and Device Performance - Performance Engineering Notes</title>


        <!-- Custom HTML head -->

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_profiling.html"><strong aria-hidden="true">2.</strong> Profiling</a></li><li class="chapter-item expanded "><a href="03_modeling.html"><strong aria-hidden="true">3.</strong> Performance Modeling</a></li><li class="chapter-item expanded "><a href="04_efficiency.html"><strong aria-hidden="true">4.</strong> Writing Efficient Code</a></li><li class="chapter-item expanded "><a href="05_parallelism.html"><strong aria-hidden="true">5.</strong> Multi-Core Systems and Parallelism</a></li><li class="chapter-item expanded "><a href="06_device_performance.html" class="active"><strong aria-hidden="true">6.</strong> System and Device Performance</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Performance Engineering Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lecture-6-system-and-device-performance"><a class="header" href="#lecture-6-system-and-device-performance">Lecture 6: System and Device Performance</a></h1>
<p>So far, we have mostly focused on CPUs and optimising for CPU performance. However, computer systems have a wide variety of components that can affect performance (memory, OS interfaces, device interfaces, etc.) and we wish to be able to be efficient on all fronts.</p>
<p>Computation and data are inextricable, so the movement of data through a system is crucial. Whether that is via IPC mechanisms, through IO devices or other low-level hardware mechanisms such as cache coherency or virtual address translation, it is important to understand that these all affect the overall performance of computation.</p>
<h2 id="hardware-related-challenges"><a class="header" href="#hardware-related-challenges">Hardware-related challenges</a></h2>
<p>To get the best performance out of systems, we need to understand the hardware. However, hardware is usually hidden away from software through various layers of abstraction. For example:</p>
<h3 id="instruction-and-memory-virtualisation"><a class="header" href="#instruction-and-memory-virtualisation">Instruction and memory virtualisation</a></h3>
<p>Deployed software often runs in virtualised environments, such as virtual machines or containers. This can lead to the virtual machine trapping into the host OS for different reasons, such as executing certain instructions. This can lead to order-of-magnitude overheads which can negatively affect performance.</p>
<p>A similar situation occurs with virtual memory. All virtual memory addresses need to be translated at runtime into physical addresses through TLBs, which are special hardware caches. This means that address translation is subject to TLB misses, making performance even harder to predict/model.
There are dedidcate <em>page walking</em> mechanisms that speculatively prefetch TLB entries by walking through the page table.</p>
<p>If we're inside a VM, then the costs are multiplied because we have &quot;nested&quot; page tables (the virtual OS + the host OS).</p>
<h3 id="memory-tiering"><a class="header" href="#memory-tiering">Memory tiering</a></h3>
<p>As we have seen many times before, memory is tiered in a hierarchy, with fast and small storage at the top and slow and large storage at the bottom of the pyramid.</p>
<p>Therefore, it is key to reduce misses and utilise caches closer to the CPU as much as possible.</p>
<h3 id="numa-and-cpu-access"><a class="header" href="#numa-and-cpu-access">NUMA and CPU access</a></h3>
<p>CPUs are connected to other CPUs through buses. For example, in Intel-based NUMA systems there is a dedicate QuickPath Interconnect (QPI) bus.</p>
<p>In the diagram below, each NUMA node consists of multiple cores and on-die caches, with a dedicated memory controller to access local memory and PCIe port to access I/O devices.</p>
<img src="assets/06_numa.png" width="500px">
<p>Note that cores on different CPUs can access each other's memory, but this is obviously much slower than access local memory.</p>
<p>In addition, different CPUs can access devices connected to different PCI ports, as well as devices accessing memory.</p>
<p>One feature offered by modern peripherals is PCIe multi-homing. As the name indicates, this means that the same device can be connected to various PCIe ports and maps memory addresses to the PCIe connection. </p>
<h3 id="cpu-and-device-interaction"><a class="header" href="#cpu-and-device-interaction">CPU and device interaction</a></h3>
<p>The traditional modes of CPU-device interaction is via interrupts and memory-mapped I/O (MMIO).</p>
<p>MMIO maps a region of addresses to the PCIe bus on which the device is connected. Every CPU write is sent as data to the device, whereas CPU reads act as a way of receiving data from the device. It is much faster to poll MMIO addresses instead of waiting for interrupts. However, it can lead to high PCIe traffic and latency (around 1μs, which is much slower compared to RAM and cache).</p>
<h2 id="io-interfaces"><a class="header" href="#io-interfaces">I/O interfaces</a></h2>
<p>Let us look at the different I/O interfaces offered by most operating systems (in particular, Linux).</p>
<p><strong>Blocking I/O</strong> is the default behaviour for the traditional system calls (<code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>, ...) as it is simple to use and understand. However, it is a blocking operation and is expensive:</p>
<ol>
<li>Trap into kernel model on syscall</li>
<li>Copy user data into kernel</li>
<li>Block and reschedule thread if I/O operation not available</li>
<li>Copy kernel data into user space</li>
</ol>
<p>A more efficient approach can be taken via <strong>non-blocking I/O APIs</strong> and generally has two flavours:</p>
<ul>
<li>
<p><em>Asynchronous</em> (designed for storage I/O): </p>
<ol>
<li>Setup the I/O operation(s) with a syscall</li>
<li>Do something else</li>
<li>Kernel signals the end of the syscall</li>
<li>React to the end of the syscall</li>
</ol>
</li>
<li>
<p><em>Events</em> (designed for network I/O):</p>
<ol>
<li>Tell kernel what operation we want to perform on a file descriptor</li>
<li>Do something else</li>
<li>Kernel signals when the operation is available</li>
<li>Operate on the file descriptor</li>
</ol>
</li>
</ul>
<h3 id="linux-asynchronous-io"><a class="header" href="#linux-asynchronous-io">Linux: asynchronous I/O</a></h3>
<p>Useful when we want to execute something else while disk file is being read or written.</p>
<ul>
<li>
<p>Submit a list of operations: </p>
<p><code>io_submit(aio_context_t ctx_id, long nr, struct iocb** iocbpp)</code></p>
</li>
<li>
<p>Wait for events to complete: </p>
<p><code>io_getevents(aio_context_t ctx_id, long min_nr, long nr, struct io_event *events)</code></p>
</li>
</ul>
<p>There are other operations to setup and cancel a list of operations.</p>
<h3 id="linux-event-based-io-with-epoll"><a class="header" href="#linux-event-based-io-with-epoll">Linux: event-based I/O (with <code>epoll</code>)</a></h3>
<p>Useful when we want to execute something else while there is no data to read from a network socket. </p>
<p>Linux offers the <code>epoll</code> API which is efficient and easy to understand, as it has evolved from <code>select</code> and <code>poll</code>. You first register the file descriptor for the reading/writing poll set and then wait for any of the fds in such sets to be ready:</p>
<ul>
<li>
<p>Register a file descriptor into the read/write poll set: </p>
<p><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></p>
</li>
<li>
<p>Wait for any fd to be ready: </p>
<p><code>epoll_wait(int epfd, struct epoll_event *events, int maxevents)</code></p>
</li>
</ul>
<p>There are other operations to setup and cancel a list of operations.</p>
<p><strong>Note:</strong> you must first set the FDs to use non-blocking I/O using <code>fcntl</code> and the <code>O_NONBLOCK</code> flag.</p>
<h3 id="linux-io_uring"><a class="header" href="#linux-io_uring">Linux: <code>io_uring</code></a></h3>
<p>The <code>io_uring</code> API covers both storage and network non-blocking operations. It works by setting up a request and response queue which is shared between the process and kernel. Queues can be manipulated and polled in user-level code, meaning that no syscalls are required to check if a response is ready. In addition, it facilitates zero-copy because the queue's memory is shared.</p>
<h3 id="direct-device-access"><a class="header" href="#direct-device-access">Direct device access</a></h3>
<p>As we have seen, performing I/O operations through the OS can be expensive. The next extreme would be to directly access hardware from user space and completely bypass the OS kernel. User code can use specialised libraries and protocols to access devices which are memory-mapped into the process' memory.</p>
<p>Examples of this are DPDK for network I/O and SPKD for storage I/O.</p>
<h2 id="design-patterns-for-io-programming"><a class="header" href="#design-patterns-for-io-programming">Design patterns for I/O programming</a></h2>
<p>This section covers some of the now obselete and more modern approaches to I/O programming for servers.</p>
<h3 id="one-thread-per-task-obsolete"><a class="header" href="#one-thread-per-task-obsolete">One thread per task (obsolete)</a></h3>
<ol>
<li>Main thread listens for new connections</li>
<li>A new connection is accepted</li>
<li>Spawns a new thread to handle the new connection</li>
<li>The new thread does all blocking operations (read from socket, execute logic, read/write disk, write to socket).</li>
</ol>
<h3 id="single-thread-pool-obsolete"><a class="header" href="#single-thread-pool-obsolete">Single thread pool (obsolete)</a></h3>
<p>The only difference with the previous approach is that we use a thread pool and recycle threads for each new connection, rather than spawning a new one. This eliminates the cost of thread creation and does not process new connections if the thread pool is exhausted.</p>
<h3 id="separate-thread-pools"><a class="header" href="#separate-thread-pools">Separate thread pools</a></h3>
<p>Here, we maintain a separate thread pool for long operations (blocking I/O). We keep the main thread busy with short operations and hand-off I/O to worker threads.</p>
<ol>
<li>Receive and process the request in the main thread</li>
<li>On a potentially long (blocking) operation, enqueue the socket fd to the worker queue</li>
<li>Workers poll the input queue</li>
<li>One worker takes the fd and executes the descriptor (eg: disk read)</li>
<li>Worker pushes the response back to main thread's queue</li>
<li>The main thread continues working using the response</li>
</ol>
<p>This is typically achieved using callbacks: the main thread function continues after the I/O worker is done.</p>
<h3 id="event-based-systems"><a class="header" href="#event-based-systems">Event-based systems</a></h3>
<p>These are designed for high throughput and low latency servers. We have many threads that operate on the same <code>epoll</code>/<code>AIO</code> context. This is typically implemented as a state machine that transitions across incoming events.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="05_parallelism.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="05_parallelism.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
