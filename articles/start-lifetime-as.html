<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Constantin-Gomez</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
    <header>
        <h1>Alex Constantin-Gomez</h1>
        <nav>
            <a href="/index.html">home</a>
            <a href="/articles.html">articles</a>
            <a href="/about.html">about</a>
        </nav>
    </header>

    <main>
        <article>
            <div class="article-header">
                <h1 class="article-title">Understanding object lifetimes in C++</h1>
                <div class="article-meta">posted: 24.03.2025</div>
            </div>

            <div class="article-content">
                <p>
                    A classic C/C++ problem every developer has come across at some point is the deserialisation of raw byte buffers, such as network packets or binary files, into Plain Old Data (POD) structures.
                    The most obvious (and conventional) solution to this problem is to simply interpret the bytes as the type of the object you are parsing. Consider the following code: 
                </p>

                <pre><code class="language-cpp">struct __attribute__((packed)) MessageHeader {
                    uint32_t seq_no;
                    uint16_t msg_type;
                    uint16_t msg_len;
                };
                
                void onPacket(uint8_t *buffer, size_t size) {
                    if (size < sizeof(MessageHeader)) return;
                
                    const auto *hdr = reinterpret_cast&lt;const MessageHeader *&gt;(buffer);
                    if (hdr->msg_type == 0)
                         foo();
                    else
                         bar();
                }</code></pre>

                <p>
                    Assuming correct alignment and field offsets, the code above looks correct. In fact, this code will work (or at least on most modern compilers). However, this 
                    code snippet has undefined behaviour. When reading the <tt>hdr->msg_type</tt> field, we are violating the strict aliasing rules defined by the language standard.
                    The strict aliasing rules dictate that an object can only be accessed through pointers of its own type (or a compatible type like char). However, we are
                    instructing the compiler to treat the sequence of bytes as a <tt>MessageHeader</tt> object. 
                </p>

                <h2>UB-free solutions</h2>
                <h3>Using <tt>memcpy</tt></h3>
                <p>The safe way to solve the problem without violating strict aliasing is to use <tt>memcpy</tt>:</p>

                <pre><code class="language-cpp">MessageHeader hdr;
                    std::memcpy(&hdr, buffer, sizeof(MessageHeader));</code></pre>

                <p>Modern compilers often optimise memcpy to generate efficient code, especially for small structs (however, there is no guarantee of this).</p>
                
                <h3>Placement new</h3>
                <p>Another alternative is to use placement new:</p>
                
                <pre><code class="language-cpp">MessageHeader *hdr = new (buffer) MessageHeader;</code></pre>

                <p>While this method avoids aliasing issues, it unnecessarily calls the constructor of MessageHeader, even when the buffer already contains a valid object representation.</p>

                <p>None of the two solutions above are ideal: we simply want to move pointers around and treat the memory as if it already was an object of type T. To understand how to solve this
                    problem without invoking undefined behaviour, we need to first understand object lifetimes in C++. 
                </p>

                <h2>Back to basics: object creation</h2>
                
        </article>
    </main>

    <!-- Prism.js scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>