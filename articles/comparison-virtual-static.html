<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Constantin-Gomez</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
    <header>
        <h1>Alex Constantin-Gomez</h1>
        <nav>
            <a href="/index.html">home</a>
            <a href="/articles.html">articles</a>
            <a href="/about.html">about</a>
        </nav>
    </header>

    <main>
        <article>
            <div class="article-header">
                <h1 class="article-title">Understanding Async/Await in JavaScript</h1>
                <div class="article-meta">$ posted: 18.01.2025 | javascript</div>
            </div>

            <div class="article-content">
                <p>Asynchronous programming is a fundamental concept in JavaScript that allows us to handle time-consuming operations without blocking the main thread. In this article, we'll explore the modern approach to handling asynchronous operations using async/await syntax.</p>

                <h2>The Evolution of Asynchronous JavaScript</h2>
                <p>Before we dive into async/await, let's briefly look at how we handled asynchronous operations in the past. This context will help us understand why async/await is such a powerful addition to the language.</p>

                <h3>The Callback Era</h3>
                <p>Traditionally, asynchronous operations were handled using callbacks:</p>

                <pre><code class="language-javascript">fetchData(function(error, data) {
    if (error) {
        console.error('Error:', error);
        return;
    }
    processData(data, function(error, processedData) {
        if (error) {
            console.error('Error:', error);
            return;
        }
        console.log('Success:', processedData);
    });
});</code></pre>

                <p>This approach often led to deeply nested callbacks, a situation known as "callback hell."</p>

                <h3>Promises: A Step Forward</h3>
                <p>Promises provided a more structured way to handle asynchronous operations:</p>

                <pre><code class="language-javascript">fetchData()
    .then(data => processData(data))
    .then(processedData => {
        console.log('Success:', processedData);
    })
    .catch(error => {
        console.error('Error:', error);
    });</code></pre>

                <h2>Enter Async/Await</h2>
                <p>Async/await syntax provides a way to write asynchronous code that looks and behaves more like synchronous code. Here's the same operation using async/await:</p>

                <pre><code class="language-javascript">async function handleData() {
    try {
        const data = await fetchData();
        const processedData = await processData(data);
        console.log('Success:', processedData);
    } catch (error) {
        console.error('Error:', error);
    }
}</code></pre>

                <h2>Key Concepts</h2>
                <ul>
                    <li>The <code>async</code> keyword declares a function that will work with asynchronous operations</li>
                    <li>The <code>await</code> keyword can only be used inside an async function</li>
                    <li>await pauses the execution until the promise resolves</li>
                    <li>Error handling uses traditional try/catch blocks</li>
                </ul>
            </div>

        </article>
    </main>

    <!-- Prism.js scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
