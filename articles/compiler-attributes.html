<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alex Constantin-Gomez</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="../styles.css">
</head>
<body>
    <header>
        <h1>Alex Constantin-Gomez</h1>
        <nav>
            <a href="index.html">home</a>
            <a href="articles.html">articles</a>
            <a href="about.html">about</a>
        </nav>
    </header>

    <main>
        <article>
            <div class="article-header">
                <h1 class="article-title">Understanding Async/Await in JavaScript</h1>
                <div class="article-meta">$ posted: 18.01.2025 | javascript</div>
            </div>

            <div class="article-content">
                <p>Modern C++ has introduced several compiler attributes that can significantly impact performance when used correctly. Let's explore some of the most interesting ones that you might not be using yet, but probably should be!</p>

                <h2>[[likely]] and [[unlikely]]</h2>
                <p>These attributes, introduced in C++20, provide branch prediction hints to the compiler. While modern CPU branch predictors are quite sophisticated, there are cases where we know better than the hardware about the probability of a condition.</p>

                <pre><code class="language-cpp">fetchData(function(error, data) {
    if (error) {
        console.error('Error:', error);
        return;
    }
    processData(data, function(error, processedData) {
        if (error) {
            console.error('Error:', error);
            return;
        }
        console.log('Success:', processedData);
    });
});</code></pre>

                <p>This approach often led to deeply nested callbacks, a situation known as "callback hell."</p>

                <h3>Promises: A Step Forward</h3>
                <p>Promises provided a more structured way to handle asynchronous operations:</p>

                <pre><code class="language-javascript">fetchData()
    .then(data => processData(data))
    .then(processedData => {
        console.log('Success:', processedData);
    })
    .catch(error => {
        console.error('Error:', error);
    });</code></pre>

                <h2>Enter Async/Await</h2>
                <p>Async/await syntax provides a way to write asynchronous code that looks and behaves more like synchronous code. Here's the same operation using async/await:</p>

                <pre><code class="language-javascript">async function handleData() {
    try {
        const data = await fetchData();
        const processedData = await processData(data);
        console.log('Success:', processedData);
    } catch (error) {
        console.error('Error:', error);
    }
}</code></pre>

                <h2>Key Concepts</h2>
                <ul>
                    <li>The <code>async</code> keyword declares a function that will work with asynchronous operations</li>
                    <li>The <code>await</code> keyword can only be used inside an async function</li>
                    <li>await pauses the execution until the promise resolves</li>
                    <li>Error handling uses traditional try/catch blocks</li>
                </ul>
            </div>

        </article>
    </main>

    <!-- Prism.js scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>